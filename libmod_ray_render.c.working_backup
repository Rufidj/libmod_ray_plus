/*
 * libmod_ray_render.c - Rendering System for Geometric Sectors
 * Complete rewrite - Build Engine style rendering
 */

#include "libmod_ray.h"
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include <SDL2/SDL.h>

/* External engine instance */
extern RAY_Engine g_engine;

/* External raycasting functions */
extern void ray_cast_ray(RAY_Engine *engine, float ray_angle, int strip_idx,
                          RAY_RayHit *hits, int *num_hits);
extern void ray_cast_sprites(RAY_Engine *engine, float ray_angle, int strip_idx,
                              RAY_RayHit *hits, int *num_hits);

/* ============================================================================
   UTILITY FUNCTIONS
   ============================================================================ */

float ray_screen_distance(float screenWidth, float fovRadians)
{
    return (screenWidth / 2.0f) / tanf(fovRadians / 2.0f);
}

float ray_strip_screen_height(float screenDistance, float correctDistance, float height)
{
    if (correctDistance < 1.0f) correctDistance = 1.0f;
    return (screenDistance / correctDistance) * height;
}

/* ============================================================================
   TEXTURE SAMPLING
   ============================================================================ */

uint32_t ray_sample_texture(GRAPH *texture, int tex_x, int tex_y)
{
    if (!texture || tex_x < 0 || tex_y < 0 ||
        tex_x >= texture->width || tex_y >= texture->height) {
        return 0;
    }
    
    return gr_get_pixel(texture, tex_x, tex_y);
}

/* ============================================================================
   FOG SYSTEM
   ============================================================================ */

uint32_t ray_fog_pixel(uint32_t pixel, float distance)
{
    if (!g_engine.fogOn) return pixel;
    
    if (distance < g_engine.fog_start_distance) return pixel;
    if (distance > g_engine.fog_end_distance) {
        return (g_engine.fog_r << 16) | (g_engine.fog_g << 8) | g_engine.fog_b;
    }
    
    float fog_factor = (distance - g_engine.fog_start_distance) /
                       (g_engine.fog_end_distance - g_engine.fog_start_distance);
    
    uint8_t r = (pixel >> 16) & 0xFF;
    uint8_t g = (pixel >> 8) & 0xFF;
    uint8_t b = pixel & 0xFF;
    
    r = (uint8_t)(r * (1.0f - fog_factor) + g_engine.fog_r * fog_factor);
    g = (uint8_t)(g * (1.0f - fog_factor) + g_engine.fog_g * fog_factor);
    b = (uint8_t)(b * (1.0f - fog_factor) + g_engine.fog_b * fog_factor);
    
    return (r << 16) | (g << 8) | b;
}

/* ============================================================================
   WALL RENDERING WITH MULTIPLE TEXTURES
   ============================================================================ */

void ray_draw_wall_strip(GRAPH *dest, RAY_RayHit *rayHit, int screen_x)
{
    if (!dest || !rayHit || !rayHit->wall) return;
    
    RAY_Wall *wall = rayHit->wall;
    
    // Skip rendering invisible portal walls
    if (wall->portal_id >= 0) return;
    
    /* DEBUG: Print first wall rendering attempt */
    static int debug_once = 0;
    if (debug_once == 0) {
        printf("RAY DEBUG: Rendering wall - textures: lower=%d, middle=%d, upper=%d\n",
               wall->texture_id_lower, wall->texture_id_middle, wall->texture_id_upper);
        debug_once = 1;
    }
    
    /* Calculate wall screen height */
    int wall_screen_height = (int)ray_strip_screen_height(g_engine.viewDist,
                                                           rayHit->correctDistance,
                                                           rayHit->wallHeight);
    
    /* Calculate player screen Z (for vertical positioning) */
    /* Calculate player screen Z (projected floor position relative to center) */
    /* player_screen_z is POSITIVE if camera > floor (looking down pushes floor down?) */
    /* Wait: If CameraZ > FloorZ, diff is positive. */
    /* Standard Projection: Y = center + (CamZ - FloorZ) / Dist * Scale */
    /* So player_screen_z should be added to center to get Floor Y */
    
    float player_screen_z = ray_strip_screen_height(g_engine.viewDist,
                                                     rayHit->correctDistance,
                                                     g_engine.camera.z - rayHit->wallZOffset);
    
    /* Calculate wall top and bottom on screen */
    /* Correct Logic: */
    /* Wall Bottom is at Floor Level = Center + player_screen_z */
    /* Wall Top is at Ceiling Level = Wall Bottom - wall_screen_height */
    
    int wall_bottom = g_engine.displayHeight / 2 + (int)player_screen_z;
    int wall_top = wall_bottom - wall_screen_height;
    
    /* Texture coordinate X (horizontal along wall) */
    int tex_x = ((int)rayHit->tileX) % RAY_TEXTURE_SIZE;
    if (tex_x < 0) tex_x += RAY_TEXTURE_SIZE;
    
    /* Calculate screen heights for texture splits */
    /* NOTE: texture_split_z values are ABSOLUTE world Z coordinates */
    /* We need to convert them to screen positions */
    float split_lower_relative = wall->texture_split_z_lower - rayHit->wallZOffset;
    float split_upper_relative = wall->texture_split_z_upper - rayHit->wallZOffset;
    
    /* Check if using default hardcoded values (64, 192) - if so, use full wall height for middle texture */
    int use_full_wall = (fabsf(wall->texture_split_z_lower - 64.0f) < 0.1f && 
                         fabsf(wall->texture_split_z_upper - 192.0f) < 0.1f);
    
    int split_lower_screen, split_upper_screen;
    
    if (use_full_wall) {
        /* Use entire wall for middle texture */
        split_lower_screen = wall_bottom; // Inverted? No, screen Y increases down. Bottom > Top.
        split_upper_screen = wall_top;    // Wait, split_lower should be closer to bottom?
        
        // Let's rethink splits.
        // Lower texture: Floor to Split1.
        // Middle texture: Split1 to Split2.
        // Upper texture: Split2 to Ceiling.
        
        // Screen Y:
        // Floor is at wall_bottom (High Y).
        // Ceiling is at wall_top (Low Y).
        
        // So Split Lower (Z=64) is closer to Floor.
        // Split Upper (Z=192) is closer to Ceiling.
        
        split_lower_screen = wall_bottom; // Default to full wall? No, full wall means middle covers everything.
        /* If use_full_wall, middle texture covers (bottom -> top). */
        /* So lower texture is empty (bottom -> bottom), upper is empty (top -> top) */
        split_lower_screen = wall_bottom;
        split_upper_screen = wall_top;
    } else {
        /* Clamp splits to wall bounds */
        if (split_lower_relative < 0) split_lower_relative = 0;
        if (split_lower_relative > rayHit->wallHeight) split_lower_relative = rayHit->wallHeight;
        if (split_upper_relative < 0) split_upper_relative = 0;
        if (split_upper_relative > rayHit->wallHeight) split_upper_relative = rayHit->wallHeight;
        
        /* Convert relative Z height to screen pixels */
        /* relative 0 = Floor (wall_bottom). relative H = Ceiling (wall_top). */
        /* Y = Bottom - (RelativeZ / WallH) * ScreenH */
        
        split_lower_screen = wall_bottom - (int)((split_lower_relative / rayHit->wallHeight) * wall_screen_height);
        split_upper_screen = wall_bottom - (int)((split_upper_relative / rayHit->wallHeight) * wall_screen_height);
    }
    
    /* Render each texture section */
    int strip_width = g_engine.stripWidth;
    
    /* LOWER TEXTURE (floor to split_lower) */
    /* Wait: Floor is at wall_bottom (High Y). Split_lower is roughly 1/4 up (Lower Y than floor). */
    /* So we want to draw from Split_Lower_Screen (Top) to Wall_Bottom (Bottom). */
    
    if (wall->texture_id_lower > 0) {
        GRAPH *texture = bitmap_get(g_engine.fpg_id, wall->texture_id_lower);
        if (texture) {
            /* Lower texture segment is visually at the BOTTOM of the wall */
            /* But in Z-space it is 0..SplitLowerZ. */
            /* In Screen space, it is from split_lower_screen (Top of this segment) to wall_bottom (Bottom of this segment). */
            /* Wait: My definitions: */
            /* split_lower_screen = wall_bottom - (relative_h / H) * ScreenH */
            /* So split_lower_screen is indeed "Above" wall_bottom. Correct. */
            
            int section_top = split_lower_screen; 
            int section_bottom = wall_bottom;
            
            for (int sy = section_top; sy < section_bottom && sy < g_engine.displayHeight; sy++) {
                if (sy < 0) continue;
                
                /* Calculate texture Y coordinate */
                float progress = (float)(sy - section_top) / (section_bottom - section_top);
                int tex_y = (int)(progress * texture->height);
                if (tex_y >= texture->height) tex_y = texture->height - 1;
                
                uint32_t pixel = ray_sample_texture(texture, tex_x, tex_y);
                if (pixel == 0) continue;  /* Transparent */
                
                if (g_engine.fogOn) {
                    pixel = ray_fog_pixel(pixel, rayHit->distance); // Use perp distance for walls usually? Or Euclidean? Stick to perp for walls or rayHit->distance which is Euclidean-ish? rayHit->distance is Euclidean.
                }
                
                for (int sx = 0; sx < strip_width && screen_x + sx < g_engine.displayWidth; sx++) {
                    gr_put_pixel(dest, screen_x + sx, sy, pixel);
                }
            }
        }
    }
    
    /* MIDDLE TEXTURE (split_lower to split_upper) */
    if (wall->texture_id_middle > 0) {
        GRAPH *texture = bitmap_get(g_engine.fpg_id, wall->texture_id_middle);
        if (texture) {
            /* Middle segment: From Split Upper (Top) to Split Lower (Bottom) */
            /* Wait: height increases UP. */
            /* Split Upper (Z=192) is HIGHER Z -> LOWER screen Y -> TOP. */
            /* Split Lower (Z=64) is LOWER Z -> HIGHER screen Y -> BOTTOM. */
            
            int section_top = split_upper_screen;
            int section_bottom = split_lower_screen;
            
            for (int sy = section_top; sy < section_bottom && sy < g_engine.displayHeight; sy++) {
                if (sy < 0) continue;
                
                float progress = (float)(sy - section_top) / (section_bottom - section_top);
                int tex_y = (int)(progress * texture->height);
                if (tex_y >= texture->height) tex_y = texture->height - 1;
                
                uint32_t pixel = ray_sample_texture(texture, tex_x, tex_y);
                if (pixel == 0) continue;
                
                if (g_engine.fogOn) {
                    pixel = ray_fog_pixel(pixel, rayHit->distance);
                }
                
                for (int sx = 0; sx < strip_width && screen_x + sx < g_engine.displayWidth; sx++) {
                    gr_put_pixel(dest, screen_x + sx, sy, pixel);
                }
            }
        }
    }
    
    /* UPPER TEXTURE (split_upper to ceiling) */
    if (wall->texture_id_upper > 0) {
        GRAPH *texture = bitmap_get(g_engine.fpg_id, wall->texture_id_upper);
        if (texture) {
            /* Upper segment: From Wall Top (Ceiling) to Split Upper */
            /* Visually TOP of wall. */
            /* From wall_top (Top) to split_upper_screen (Bottom of this segment). */
            
            int section_top = wall_top;
            int section_bottom = split_upper_screen;
            
            for (int sy = section_top; sy < section_bottom && sy < g_engine.displayHeight; sy++) {
                if (sy < 0) continue;
                
                float progress = (float)(sy - section_top) / (section_bottom - section_top);
                int tex_y = (int)(progress * texture->height);
                if (tex_y >= texture->height) tex_y = texture->height - 1;
                
                uint32_t pixel = ray_sample_texture(texture, tex_x, tex_y);
                if (pixel == 0) continue;
                
                if (g_engine.fogOn) {
                    pixel = ray_fog_pixel(pixel, rayHit->distance);
                }
                
                for (int sx = 0; sx < strip_width && screen_x + sx < g_engine.displayWidth; sx++) {
                    gr_put_pixel(dest, screen_x + sx, sy, pixel);
                }
            }
        }
    }
}

/* ============================================================================
   FLOOR AND CEILING RENDERING
   ============================================================================ */

void ray_draw_floor_ceiling(GRAPH *dest, int screen_x, float ray_angle,
                             int sector_id, float min_distance, float max_distance)
{
    if (!dest) return;
    
    int strip_width = g_engine.stripWidth;
    float cos_factor = cosf(ray_angle - g_engine.camera.rot);
    
    /* Find the specified sector */
    RAY_Sector *sector = NULL;
    for (int i = 0; i < g_engine.num_sectors; i++) {
        if (g_engine.sectors[i].sector_id == sector_id) {
            sector = &g_engine.sectors[i];
            break;
        }
    }
    if (!sector) return;
    
    /* Calculate wall screen height for clipping */
    int wall_screen_height = 0;
    float player_screen_z = 0;
    
    if (max_distance < FLT_MAX) {
        wall_screen_height = (int)ray_strip_screen_height(g_engine.viewDist,
                                                           max_distance,
                                                           sector->ceiling_z - sector->floor_z);
        player_screen_z = ray_strip_screen_height(g_engine.viewDist,
                                                   max_distance,
                                                   g_engine.camera.z - sector->floor_z);
    }
    
    /* Calculate boundaries for floor/ceiling rendering */
    int half_height = g_engine.displayHeight / 2;
    
    /* Calculate minimum dy needed for floor/ceiling to be within max_distance */
    float distance_to_floor = g_engine.camera.z - sector->floor_z;
    float distance_to_ceiling = sector->ceiling_z - g_engine.camera.z;
    
    int min_dy_floor = 1;
    if (max_distance < FLT_MAX && max_distance > 0.1f && distance_to_floor > 0.1f) {
        min_dy_floor = (int)((g_engine.viewDist * distance_to_floor) / max_distance) + 1;
        if (min_dy_floor < 1) min_dy_floor = 1;
        if (min_dy_floor > 100) min_dy_floor = 100;
    }
    
    int min_dy_ceiling = 1;
    if (max_distance < FLT_MAX && max_distance > 0.1f && distance_to_ceiling > 0.1f) {
        min_dy_ceiling = (int)((g_engine.viewDist * distance_to_ceiling) / max_distance) + 1;
        if (min_dy_ceiling < 1) min_dy_ceiling = 1;
        if (min_dy_ceiling > 100) min_dy_ceiling = 100;
    }
    
    /* Floor starts from calculated position and goes DOWN to bottom of screen */
    int floor_start_y = half_height + min_dy_floor;
    if (floor_start_y >= g_engine.displayHeight) floor_start_y = g_engine.displayHeight - 1;
    
    /* Ceiling ends at calculated position (from top DOWN to this point) */
    int ceiling_end_y = half_height - min_dy_ceiling;
    if (ceiling_end_y < 0) ceiling_end_y = 0;
    
    
    /* FLOOR RENDERING */
    if (g_engine.drawTexturedFloor && sector->floor_texture_id > 0) {
        GRAPH *floor_texture = bitmap_get(g_engine.fpg_id, sector->floor_texture_id);
        if (floor_texture) {
            for (int screen_y = floor_start_y; screen_y < g_engine.displayHeight; screen_y++) {
                int dy = screen_y - half_height;
                if (dy == 0) continue;
                
                float distance_to_floor = g_engine.camera.z - sector->floor_z;
                if (distance_to_floor <= 0.1f) continue;
                
                float ratio = distance_to_floor / (float)dy;
                float perp_distance = g_engine.viewDist * ratio;
                
                float angle_diff = ray_angle - g_engine.camera.rot;
                float euclidean_distance = perp_distance / cosf(angle_diff);
                
                if (euclidean_distance < min_distance) continue;
                if (euclidean_distance > max_distance) break;
                
                float x_end = g_engine.camera.x + euclidean_distance * cosf(ray_angle);
                float y_end = g_engine.camera.y + euclidean_distance * -sinf(ray_angle);
                
                int tex_x = ((int)x_end) % RAY_TEXTURE_SIZE;
                int tex_y = ((int)y_end) % RAY_TEXTURE_SIZE;
                if (tex_x < 0) tex_x += RAY_TEXTURE_SIZE;
                if (tex_y < 0) tex_y += RAY_TEXTURE_SIZE;
                
                tex_x = (tex_x * floor_texture->width) / RAY_TEXTURE_SIZE;
                tex_y = (tex_y * floor_texture->height) / RAY_TEXTURE_SIZE;
                
                uint32_t pixel = ray_sample_texture(floor_texture, tex_x, tex_y);
                
                if (g_engine.fogOn) {
                    pixel = ray_fog_pixel(pixel, euclidean_distance);
                }
                
                for (int sx = 0; sx < strip_width && screen_x + sx < g_engine.displayWidth; sx++) {
                    gr_put_pixel(dest, screen_x + sx, screen_y, pixel);
                }
            }
        }
    }
    
    /* CEILING RENDERING */
    if (g_engine.drawCeiling && sector->ceiling_texture_id > 0) {
        GRAPH *ceiling_texture = bitmap_get(g_engine.fpg_id, sector->ceiling_texture_id);
        if (ceiling_texture) {
            for (int screen_y = 0; screen_y < ceiling_end_y; screen_y++) {
                int dy = half_height - screen_y;
                if (dy == 0) continue;
                
                float distance_to_ceiling = sector->ceiling_z - g_engine.camera.z;
                if (distance_to_ceiling <= 0.1f) continue;
                
                float ratio = distance_to_ceiling / (float)dy;
                float perp_distance = g_engine.viewDist * ratio;
                
                float angle_diff = ray_angle - g_engine.camera.rot;
                float euclidean_distance = perp_distance / cosf(angle_diff);
                
                if (euclidean_distance < min_distance) continue;
                if (euclidean_distance > max_distance) break;
                
                float x_end = g_engine.camera.x + euclidean_distance * cosf(ray_angle);
                float y_end = g_engine.camera.y + euclidean_distance * -sinf(ray_angle);
                
                int tex_x = ((int)x_end) % RAY_TEXTURE_SIZE;
                int tex_y = ((int)y_end) % RAY_TEXTURE_SIZE;
                if (tex_x < 0) tex_x += RAY_TEXTURE_SIZE;
                if (tex_y < 0) tex_y += RAY_TEXTURE_SIZE;
                
                tex_x = (tex_x * ceiling_texture->width) / RAY_TEXTURE_SIZE;
                tex_y = (tex_y * ceiling_texture->height) / RAY_TEXTURE_SIZE;
                
                uint32_t pixel = ray_sample_texture(ceiling_texture, tex_x, tex_y);
                
                if (g_engine.fogOn) {
                    pixel = ray_fog_pixel(pixel, euclidean_distance);
                }
                
                for (int sx = 0; sx < strip_width && screen_x + sx < g_engine.displayWidth; sx++) {
                    gr_put_pixel(dest, screen_x + sx, screen_y, pixel);
                }
            }
        }
    }
}

/* ============================================================================
   SPRITE RENDERING
   ============================================================================ */

static int ray_sprite_sorter(const void *a, const void *b)
{
    const RAY_Sprite *sa = (const RAY_Sprite*)a;
    const RAY_Sprite *sb = (const RAY_Sprite*)b;
    
    if (sa->distance > sb->distance) return -1;
    if (sa->distance < sb->distance) return 1;
    return 0;
}

void ray_draw_sprites(GRAPH *dest, float *z_buffer)
{
    if (!dest || !z_buffer) return;
    
    /* Calculate sprite distances */
    for (int i = 0; i < g_engine.num_sprites; i++) {
        RAY_Sprite *sprite = &g_engine.sprites[i];
        if (sprite->hidden || sprite->cleanup) continue;
        
        float dx = sprite->x - g_engine.camera.x;
        float dy = sprite->y - g_engine.camera.y;
        sprite->distance = sqrtf(dx * dx + dy * dy);
    }
    
    /* Sort sprites by distance */
    qsort(g_engine.sprites, g_engine.num_sprites, sizeof(RAY_Sprite), ray_sprite_sorter);
    
    /* Render sprites */
    for (int i = 0; i < g_engine.num_sprites; i++) {
        RAY_Sprite *sprite = &g_engine.sprites[i];
        if (sprite->hidden || sprite->cleanup || sprite->distance == 0) continue;
        
        float dx = sprite->x - g_engine.camera.x;
        float dy = sprite->y - g_engine.camera.y;
        float sprite_angle = atan2f(-dy, dx);
        
        while (sprite_angle - g_engine.camera.rot > M_PI) sprite_angle -= RAY_TWO_PI;
        while (sprite_angle - g_engine.camera.rot < -M_PI) sprite_angle += RAY_TWO_PI;
        
        float angle_diff = sprite_angle - g_engine.camera.rot;
        
        if (fabsf(angle_diff) > g_engine.fovRadians / 2.0f + 0.5f) continue;
        
        float sprite_screen_x = tanf(angle_diff) * g_engine.viewDist;
        int screen_x = g_engine.displayWidth / 2 - (int)sprite_screen_x;
        
        float sprite_screen_height = (g_engine.viewDist / sprite->distance) * sprite->h;
        float sprite_screen_width = (g_engine.viewDist / sprite->distance) * sprite->w;
        
        float sprite_z_offset = sprite->z - g_engine.camera.z;
        float sprite_screen_z = (g_engine.viewDist / sprite->distance) * sprite_z_offset;
        
        int screen_y = g_engine.displayHeight / 2 - (int)(sprite_screen_height / 2) + (int)sprite_screen_z;
        
        GRAPH *sprite_texture = NULL;
        if (sprite->process_ptr) {
            sprite_texture = instance_graph(sprite->process_ptr);
        }
        if (!sprite_texture && sprite->textureID > 0) {
            sprite_texture = bitmap_get(g_engine.fpg_id, sprite->textureID);
        }
        if (!sprite_texture) continue;
        
        int start_x = screen_x - (int)(sprite_screen_width / 2);
        int end_x = screen_x + (int)(sprite_screen_width / 2);
        
        for (int sx = start_x; sx < end_x; sx++) {
            if (sx < 0 || sx >= g_engine.displayWidth) continue;
            
            int strip = sx / g_engine.stripWidth;
            if (strip >= 0 && strip < g_engine.rayCount) {
                if (z_buffer[strip] > 0 && sprite->distance > z_buffer[strip]) {
                    continue;
                }
            }
            
            float tex_x_f = ((float)(sx - start_x) / sprite_screen_width) * sprite_texture->width;
            int tex_x = (int)tex_x_f;
            if (tex_x < 0 || tex_x >= sprite_texture->width) continue;
            
            for (int sy = screen_y; sy < screen_y + (int)sprite_screen_height; sy++) {
                if (sy < 0 || sy >= g_engine.displayHeight) continue;
                
                float tex_y_f = ((float)(sy - screen_y) / sprite_screen_height) * sprite_texture->height;
                int tex_y = (int)tex_y_f;
                if (tex_y < 0 || tex_y >= sprite_texture->height) continue;
                
                uint32_t pixel = gr_get_pixel(sprite_texture, tex_x, tex_y);
                if (pixel == 0) continue;
                
                if (g_engine.fogOn) {
                    pixel = ray_fog_pixel(pixel, sprite->distance);
                }
                
                gr_put_pixel(dest, sx, sy, pixel);
            }
        }
    }
}

/* ============================================================================
   MAIN RENDER FUNCTION
   ============================================================================ */

/* Hit sorter for painter's algorithm */
static int ray_hit_sorter(const void *a, const void *b)
{
    const RAY_RayHit *ha = (const RAY_RayHit*)a;
    const RAY_RayHit *hb = (const RAY_RayHit*)b;
    
    if (ha->distance < hb->distance) return -1;
    if (ha->distance > hb->distance) return 1;
    return 0;
}

void ray_render_frame(GRAPH *dest)
{
    if (!dest || !g_engine.initialized) return;
    
    /* DEBUG: Print camera and sector info */
    static int debug_counter = 0;
    if (debug_counter++ % 60 == 0) {  // Print every 60 frames
         // ... (keep existing debug code) ...
    }
    
    /* Clear screen with sky color */
    uint32_t sky_color = 0x87CEEB;
    gr_clear_as(dest, sky_color);
    
    /* Render skybox if available */
    if (g_engine.skyTextureID > 0) {
        GRAPH *sky_texture = bitmap_get(g_engine.fpg_id, g_engine.skyTextureID);
        if (sky_texture) {
            int sky_height = dest->height / 2;
            for (int x = 0; x < dest->width; x++) {
                float screen_angle = ((float)x / dest->width - 0.5f) * g_engine.fovRadians;
                float total_angle = g_engine.camera.rot + screen_angle;
                total_angle = fmodf(total_angle, 2.0f * M_PI);
                if (total_angle < 0) total_angle += 2.0f * M_PI;
                
                int tex_x = (int)((total_angle / (2.0f * M_PI)) * sky_texture->width);
                if (tex_x >= sky_texture->width) tex_x = sky_texture->width - 1;
                
                for (int y = 0; y < sky_height; y++) {
                    int tex_y = (y * sky_texture->height) / sky_height;
                    if (tex_y >= sky_texture->height) tex_y = sky_texture->height - 1;
                    
                    uint32_t pixel = ray_sample_texture(sky_texture, tex_x, tex_y);
                    gr_put_pixel(dest, x, y, pixel);
                }
            }
        }
    }
    
    /* Allocate buffers */
    // Using simple stack allocation for small arrays if possible, but rayCount is dynamic
    // optimization: reuse static buffers if possible, but for now stick to malloc
    RAY_RayHit *all_rayhits = (RAY_RayHit*)malloc(g_engine.rayCount * RAY_MAX_RAYHITS * sizeof(RAY_RayHit));
    int *rayhit_counts = (int*)calloc(g_engine.rayCount, sizeof(int));
    float *z_buffer = (float*)malloc(g_engine.rayCount * sizeof(float));
    
    if (!all_rayhits || !rayhit_counts || !z_buffer) {
        if (all_rayhits) free(all_rayhits);
        if (rayhit_counts) free(rayhit_counts);
        if (z_buffer) free(z_buffer);
        return;
    }
    
    /* Initialize z-buffer */
    for (int i = 0; i < g_engine.rayCount; i++) {
        z_buffer[i] = FLT_MAX;
    }
    
    /* RAYCAST PHASE */
    // Parallelize this loop if possible in future
    for (int strip = 0; strip < g_engine.rayCount; strip++) {
        float strip_angle = g_engine.stripAngles[strip];
        float ray_angle = g_engine.camera.rot + strip_angle;
        int num_hits = 0;
        
        /* Cast ray against walls */
        ray_cast_ray(&g_engine, ray_angle, strip,
                     &all_rayhits[strip * RAY_MAX_RAYHITS], &num_hits);
        
        /* Cast ray against sprites */
        ray_cast_sprites(&g_engine, ray_angle, strip,
                         &all_rayhits[strip * RAY_MAX_RAYHITS], &num_hits);
        
        rayhit_counts[strip] = num_hits;
        
        /* Update z-buffer with closest wall */
        for (int h = 0; h < num_hits; h++) {
            RAY_RayHit *hit = &all_rayhits[strip * RAY_MAX_RAYHITS + h];
            if (hit->wall && hit->distance < z_buffer[strip]) {
                z_buffer[strip] = hit->distance;
            }
        }
    }
    
    /* RENDER PHASE */
    for (int strip = 0; strip < g_engine.rayCount; strip++) {
        int screen_x = strip * g_engine.stripWidth;
        float ray_angle = g_engine.camera.rot + g_engine.stripAngles[strip];
        
        int num_hits = rayhit_counts[strip];
        RAY_RayHit *hits = &all_rayhits[strip * RAY_MAX_RAYHITS];
        
        /* Sort hits by distance (ascending) to ensure correct Painter's Algorithm */
        if (num_hits > 1) {
            qsort(hits, num_hits, sizeof(RAY_RayHit), ray_hit_sorter);
        }
        
        /* Find closest wall hit for floor/ceiling clipping */
        RAY_RayHit *closest_wall = NULL;
        float closest_dist = FLT_MAX;
        
        for (int h = 0; h < num_hits; h++) {
            if (hits[h].wall && hits[h].distance < closest_dist) {
                closest_wall = &hits[h];
                closest_dist = hits[h].distance;
            }
        }
        
        /* Get camera sector */
        RAY_Sector *camera_sector = ray_find_sector_at_point(&g_engine,
                                                              g_engine.camera.x,
                                                              g_engine.camera.y);
        
        /* Render floor and ceiling of camera sector */
        if (camera_sector) {
            ray_draw_floor_ceiling(dest, screen_x, ray_angle,
                                   camera_sector->sector_id, 0.0f, 
                                   closest_wall ? closest_wall->distance : FLT_MAX);
        }
        
        /* Render walls (back to front) */
        for (int h = num_hits - 1; h >= 0; h--) {
            if (hits[h].wall) {
                ray_draw_wall_strip(dest, &hits[h], screen_x);
            }
        }
    }
    
    /* Render sprites */
    ray_draw_sprites(dest, z_buffer);
    
    /* Cleanup */
    free(all_rayhits);
    free(rayhit_counts);
    free(z_buffer);
}
